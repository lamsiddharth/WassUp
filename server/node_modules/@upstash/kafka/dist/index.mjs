var p=class{client;constructor(t){this.client=t}async topics(){return await this.client.get({path:["topics"]})}async consumers(){return await this.client.get({path:["consumers"]})}async removeConsumerInstance(t,e){await this.client.post({path:["delete-consumer",t,e]})}async committedOffsets(t){return await this.client.post({path:["committed",t.consumerGroupId,t.instanceId],body:t.topicPartition?[t.topicPartition]:t.topicPartitions})}async topicPartitionOffsets(t){return await this.client.post({path:["offsets",t.timestamp.toString()],body:t.topicPartition?[t.topicPartition]:t.topicPartitions})}};function f(r){let t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",e=r.length-1,s=-1,i="";for(;s<e;){let n=r.charCodeAt(++s)<<16|r.charCodeAt(++s)<<8|r.charCodeAt(++s);i+=t[n>>>18&63]+t[n>>>12&63]+t[n>>>6&63]+t[n&63]}let o=r.length%3;if(o>0)for(i=i.slice(0,o-3);i.length%4!==0;)i+="=";return i}var a=class{client;constructor(t){this.client=t}async fetch(t,e={parallel:!0}){let s=[t];return e?.parallel&&(s=(t.topicPartitionOffsets??[]).map(o=>({...o,timeout:t.timeout})),t.topic&&s.push({topic:t.topic,partition:t.partition,offset:t.offset,timeout:t.timeout})),(await Promise.all(s.map(async o=>await this.client.post({path:["fetch"],body:o})))).flat()}async consume(t){let e={};t.topics.length===1?e.topic=t.topics[0]:e.topics=t.topics,typeof t.timeout=="number"&&(e.timeout=t.timeout);let s={};return typeof t.autoCommit=="boolean"&&(s["Kafka-Enable-Auto-Commit"]=t.autoCommit.toString()),typeof t.autoCommitInterval=="number"&&(s["Kafka-Auto-Commit-Interval"]=t.autoCommitInterval.toString()),typeof t.autoOffsetReset=="string"&&(s["Kafka-Auto-Offset-Reset"]=t.autoOffsetReset),await this.client.post({path:["consume",t.consumerGroupId,t.instanceId],headers:s,body:e})}async commit(t){return await this.client.post({path:["commit",t.consumerGroupId,t.instanceId],body:t.offset})}async committed(t){return await this.client.post({path:["committed",t.consumerGroupId,t.instanceId],body:t.topicPartitions})}};var c=class extends Error{result;error;status;constructor(t){super(t.error),this.name="UpstashError",this.result=t.result,this.error=t.error,this.status=t.status}};var u=class{baseUrl;headers;constructor(t){this.baseUrl=t.baseUrl.replace(/\/$/,""),this.headers=t.headers??{}}async request(t,e){let s={"Content-Type":"application/json",...this.headers,...e.headers},i=new Error;for(let o=0;o<=(e.retries??5);o++){o>0&&await new Promise(n=>setTimeout(n,2**o*250));try{let n=await fetch([this.baseUrl,...e.path].join("/"),{method:t,headers:s,keepalive:!0,body:JSON.stringify(e.body)}),l=await n.json();if(!n.ok)throw new c(l);return l}catch(n){i=n}}throw i}async get(t){return await this.request("GET",t)}async post(t){return await this.request("POST",t)}};var m=class{client;constructor(t){this.client=t}async produce(t,e,s){let i={topic:t,value:typeof e=="string"?e:JSON.stringify(e),...s};return(await this.client.post({path:["produce"],body:i}))[0]}async produceMany(t){let e=t.map(({value:s,...i})=>({...i,value:typeof s=="string"?s:JSON.stringify(s)}));return await this.client.post({path:["produce"],body:e})}};var d=class{client;constructor(t){this.client=new u({baseUrl:t.url,headers:{authorization:`Basic ${f(`${t.username}:${t.password}`)}`}})}producer(){return new m(this.client)}consumer(){return new a(this.client)}admin(){return new p(this.client)}};export{d as Kafka,c as UpstashError};
